/* ************************************************************************** *//*                                                                            *//*                                                        :::      ::::::::   *//*   main.c                                             :+:      :+:    :+:   *//*                                                    +:+ +:+         +:+     *//*   By: desausag <desausag@student.42.fr>          +#+  +:+       +#+        *//*                                                +#+#+#+#+#+   +#+           *//*   Created: 2021/03/20 18:02:25 by desausag          #+#    #+#             *//*   Updated: 2021/03/25 22:53:33 by desausag         ###   ########.fr       *//*                                                                            *//* ************************************************************************** */#include "./game/ft_game.h"double	print_wall(t_cord cross,t_all *all, int x, t_cord ray, int side){	double d_to_wall;	t_cord edge;	double h;	double i;	unsigned int color;	double k;	int tmp1;	int tmp2;	int wall;	i = 0;	d_to_wall = len_ray(all->plr.pos, cross) * angle(all->plr.dir, ray);	h = all->textures.height/(d_to_wall);  // line height	edge = v_set(all->textures.height/2 - h/2, all->textures.height/2 + h/2);	k = all->txre_img[side].h / h;	while (i <= all->textures.height)	{		if (i > edge.x  && i < edge.y) //смотрим по высоте		{			tmp2 = (int)(k * (i - edge.x));			if (side == 1)//NO&&SO			{				if (ray.y > 0)					wall = 1;				else					wall = 0;				tmp1 = (int)((cross.x - floor(cross.x)) * all->txre_img[wall].w);			}			else if (side == 0)//we ea			{				if (ray.x > 0)					wall = 3;				else					wall = 2;				tmp1 = (int)((cross.y - floor(cross.y)) * all->txre_img[wall].w);			}			color = get_color(all->txre_img[wall], tmp1, tmp2); //достать пиксель			my_mlx_pixel_put(all, x, i, color);		}		if (i <= edge.x)			my_mlx_pixel_put(all, x, i, 0xAFEEEE);		if (i >= edge.y)			my_mlx_pixel_put(all, x, i, 0xCD853F);		i++;	}	return (edge.x);}void	draw_sprite(t_all *all, t_sprite spr){	int i;	int j;	double h;	double k;	t_cord edge;	int tmp2;	int tmp1;	h = all->textures.height/len_ray(all->plr.pos, spr.pos);  // line height	edge = v_set(all->textures.height/2 - h/2, all->textures.height/2 + h/2);	k = all->txre_img[4].w / h;	i = spr.cent - h / 2;	while (++i < (spr.cent + h / 2))	{		tmp1 = (spr.cent -h/2 + i)/all->txre_img[4].w;		j = -1;		while (++j < edge.y)			if (j > edge.x  && j < edge.y) //смотрим по высоте			{				tmp2 = (int) (k * (j - edge.x));				my_mlx_pixel_put(all, i, j,  get_color(all->txre_img[4], tmp1, tmp2));			}	}}double	print_sprite(t_all *all){	int 	i;	i = -1;	while (++i < all->sprt->co)		if (all->sprt[i].vis)			draw_sprite(all, all->sprt[i]);}void	null_sprites(t_all *all){	int i;	i = -1;	while (++i < all->sprt->co)		all->sprt[i].vis = 0;}int		ray_cast(t_all *all, t_cord *cross, t_cord ray, t_cord dot_b){	t_cord b_x = {0, 1};//вектор по x	t_cord b_y = {1, 0};//вектор по y	int side;	t_cord cross_x;	while (!(is_wall_cord(all->map, *cross, ray)))	{		cross_x = crc(ray, b_x, all->plr.pos, dot_b);//точка пересечения по х		*cross = crc(ray, b_y, all->plr.pos, dot_b);//точка пересечения по у		if (len_ray(all->plr.pos, cross_x) < len_ray(all->plr.pos, *cross))//если по х ближе чем по у		{			side = 0;			*cross = cross_x;			dot_b = fwd_pnt(ray, dot_b, 1);		}		else //Если у ближе чем х		{			side = 1;			dot_b = fwd_pnt(ray, dot_b, -1);		}		my_mlx_pixel_put(all, (*cross).x * SCALE, (*cross).y * SCALE, 0xFF10100);		t_cord cell;		if ((cell = is_sprite(all->map, *cross, ray)).x != -1)		{			sprite(all->textures.spr, all, ray);			init_sprite(all, cell);		}	}	return (side);}void	draw_screen(t_all *all){	t_cord cross;	t_cord cross_x;//вектор пересечения луча и х координаты	t_cord dot_b;//точка на векторе сетки	t_cord ray;	int side;	int i = 0;	t_cord	buf[all->textures.width];	char **map = all->map;	mlx_destroy_image(all->win.mlx, all->win.img);	init_img(all);	scale_pix(all, map);	ray = rotateZ(all->plr.dir, -(float)VIEW/2);	all->ray0 = ray;	null_sprites(all);	while (i < all->textures.width)//привязать к ширине экрана	{		dot_b = net_point(ray, all->plr.pos);//точка пересечения сетки		cross = all->plr.pos;		side = ray_cast(all, &cross, ray, dot_b);		print_wall(cross,all, i, ray, side);		ray = rotateZ(ray, (double)VIEW/all->textures.width);		i++;	}	print_sprite(all);	mlx_put_image_to_window(all->win.mlx, all->win.mlx_win, all->win.img, 0, 0);}int		main(int argc, char **argv) {    t_textures textures;    t_all all;    if (!open_file(argv[1], &textures, &all))        return (0);    all.textures = textures;	all.plr = textures.plr;	all.map = textures.map;	all.win.mlx = mlx_init();	all.win.mlx_win = mlx_new_window(all.win.mlx, textures.width, textures.height, "Cub3d!");	init_texture(&all);    init_img(&all);	draw_screen(&all);   // mlx_key_hook(img.mlx_win, key_hook, &all); 	//mlx_loop_hook(all.win->mlx, draw_screen, all.win);    mlx_hook(all.win.mlx_win, 2, 1L<<0, key_hook, &all);	mlx_loop(all.win.mlx);	return 0;}