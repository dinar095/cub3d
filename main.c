/* ************************************************************************** *//*                                                                            *//*                                                        :::      ::::::::   *//*   main.c                                             :+:      :+:    :+:   *//*                                                    +:+ +:+         +:+     *//*   By: desausag <desausag@student.42.fr>          +#+  +:+       +#+        *//*                                                +#+#+#+#+#+   +#+           *//*   Created: 2021/03/20 18:02:25 by desausag          #+#    #+#             *//*   Updated: 2021/04/06 20:59:25 by desausag         ###   ########.fr       *//*                                                                            *//* ************************************************************************** */#include "./game/ft_game.h"void	err(char *s){	ft_putstr_fd(s, 1);	exit(1);}static void			init_bmp_header(t_all *all, int fd){	int				val;	write(fd, "BM", 2);	val = 14 + 40 + all->textures.width * all->textures.height *					all->win.bpp / 8;	write(fd, &val, 4);	write(fd, "\0\0\0\0", 4);	val = 14 + 40;	write(fd, &val, 4);	val = 40;	write(fd, &val, 4);	write(fd, &all->textures.width, 4);	write(fd, &all->textures.height, 4);	val = 1;	write(fd, &val, 2);	write(fd, &all->win.bpp, 2);	write(fd, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 24);}void				screen_image(t_all *all){	char			*file_name;	int				fd;	int				i;	file_name = "screen.bmp";	fd = open(file_name, O_RDWR | O_CREAT | O_TRUNC, 0666);	if (fd < 0)		err("Can't open file\n");	init_bmp_header(all, fd);	i = all->textures.height;	while (i-- > 0)	{		write(fd, (all->win.addr + i * all->win.line_l),			  (all->textures.width * all->win.bpp / 8));	}	close(fd);	exit(0);}void vis(t_all *all, t_cord *y){}double	print_wall(t_cord plr,t_cord cross, t_textures textures, t_all *all, int x, t_cord ray, int side){	double d_to_wall;	t_cord y;	double h;	double i;	unsigned int color;	double k;	int tmp1;	int tmp2;	int wall;	i = 0;	d_to_wall = len_ray(plr, cross) * angle(all->plr.dir, ray);	h = textures.height/(d_to_wall);  // line height	y.x = textures.height/2 - h/2;	y.y = textures.height/2 + h/2;	k = all->txre_img[side].h / h;	while (i <= textures.height)	{		if (i > y.x  && i < y.y) //смотрим по высоте		{			tmp2 = (int) (k * (i - y.x));			if (side == 1)//NO&&SO			{				if (ray.y > 0)					wall = 1;				else					wall = 0;				tmp1 = (int)((cross.x - floor(cross.x)) * all->txre_img[wall].w);			}			else if (side == 0)//we ea			{				if (ray.x > 0)					wall = 3;				else					wall = 2;				tmp1 = (int)((cross.y - floor(cross.y)) * all->txre_img[wall].w);			}			color = get_color(all->txre_img[wall], tmp1, tmp2); //достать пиксель			my_mlx_pixel_put(all, x, i, color);		}		if (i <= y.x)			my_mlx_pixel_put(all, x, i, 0xAFEEEE);		if (i >= y.y)			my_mlx_pixel_put(all, x, i, 0xCD853F);		i++;	}	return (y.x);}void	sort_sprite(t_all *all){	t_sprite newSprite;	int location;	int i;	i = 1;	while (i < all->sprite[0].co)	{		newSprite = all->sprite[i];		location = i - 1;		while(location >= 0 && all->sprite[location].dist < newSprite.dist)		{			all->sprite[location+1] = all->sprite[location];			location = location - 1;		}		all->sprite[location+1] = newSprite;		i++;	}}void	draw_sprite(t_all *all, t_sprite spr, double *zBuf){	t_int i;	t_cord h;	t_cord y;	t_int tmp;	int color;	h.x = all->textures.height/len_ray(all->plr.pos, spr.pos);	y.x = all->textures.height/2 - h.x/2;	y.y = all->textures.height/2 + h.x/2;	h.y = all->txre_img[4].w / h.x;	i.i = spr.cent - h.x / 2;	while (++i.i < (spr.cent + h.x / 2))		if (i.i > 0 && i.i < all->textures.width)		{			tmp.i = (i.i - spr.cent + h.x / 2) * h.y;//сброс верхней точки			i.j = -1;			while (++i.j < y.y)				if (i.j > y.x  && i.j < y.y && y.x <= zBuf[i.i]) //смотрим по высоте				{					tmp.j = (int) (h.y * (i.j - y.x));					if ((color = get_color(all->txre_img[4], tmp.i, tmp.j)))						my_mlx_pixel_put(all, i.i, i.j, color);				}		}}double	print_sprite(t_all *all, double *zBuf){	int 		i;	i = -1;	while (++i < all->sprite->co)		all->sprite[i].dist = len_ray(all->sprite[i].pos, all->plr.pos);	sort_sprite(all);	i = -1;	while (++i < all->sprite->co)	{		if (all->sprite[i].vis)			draw_sprite(all, all->sprite[i], zBuf);	}}void	init_sprite(t_all *all,t_cord cross){	int i;	t_cord vec;	double ugol;	int		znak;	i = -1;	while (++i < all->sprite->co)	{		if ((int)all->sprite[i].pos.x == (int)cross.x && (int)all->sprite[i].pos.y == (int)cross.y		&& all->sprite[i].vis == 0)		{			all->sprite[i].vis = 1;			vec = v_set(all->sprite[i].pos.x - all->plr.pos.x, all->sprite[i].pos.y - all->plr.pos.y);//вектор до центра спрайта			znak = all->ray0.x * vec.y - all->ray0.y * vec.x < 0 ? -1 : 1;			ugol = acos(angle(all->ray0, vec)) * znak * 180 / M_PI;			all->sprite[i].cent = ugol / 46 * all->textures.width;		}	}}void	draw_screen(t_all *all){	t_cord b_x = {0, 1};//вектор по x	t_cord b_y = {1, 0};//вектор по y	t_cord cross;	t_cord cross_x;//вектор пересечения луча и х координаты	t_cord dot_b;//точка на векторе сетки	t_cord ray;	double 	zbuf[all->textures.width];	int i = 0;	char **map = all->map;	mlx_destroy_image(all->win.mlx, all->win.img);	init_img(all);	int side;	float angel;	angel = 46;	ray = rotateZ(all->plr.dir, -angel/2, all->si_co);	all->ray0 = ray;	null_sprites(all);	while (i < all->textures.width)//привязать к ширине экрана	{        dot_b = net_point(ray, all->plr.pos);//точка пересечения сетки		cross = all->plr.pos;		while (!(is_wall_cord(map, cross, ray)))		{			cross_x = crc(ray, b_x, all->plr.pos, dot_b);//точка пересечения по х			cross = crc(ray, b_y, all->plr.pos, dot_b);//точка пересечения по у			if (len_ray(all->plr.pos, cross_x) < len_ray(all->plr.pos, cross))//если по х ближе чем по у			{				side = 0;				cross = cross_x;				dot_b = fwd_pnt(ray, dot_b, 1);			}			else //Если у ближе чем х			{				side = 1;                dot_b = fwd_pnt(ray, dot_b, -1);			}			t_cord cell;			if ((cell = is_sprite(map, cross, ray)).x != -1)				init_sprite(all, cell);		}		zbuf[i] = print_wall(all->plr.pos, cross, all->textures, all, i, ray, side);        ray = rotateZ(ray, 0, all->si_co);		i++;	}	print_sprite(all, zbuf);	if (all->save == 1)		screen_image(all);	mlx_put_image_to_window(all->win.mlx, all->win.mlx_win, all->win.img, 0, 0);}static void		check_display_resolution(t_all *all){	int wide;	int height;	if (!all->save)	{		mlx_get_screen_size(all->win.mlx, &wide, &height);		if (wide < all->textures.width)			all->textures.width = wide;		if (height < all->textures.height)			all->textures.height = height;	}}int		check_ext(const char *f_name){	int c;	c = ft_strlen(f_name);	if (c > 6 && !ft_strncmp(f_name + (c-4), ".cub", 4))		return (1);	return 0;}int		main(int argc, char **argv) {    t_textures textures;    t_all all;    if (argc == 1 && check_ext(argv[1]))    	err("Error arguments\n");    if (!open_file(argv[1], &textures, &all))        err("Error file\n");    all.textures = textures;	all.plr = textures.plr;	all.map = textures.map;	all.save = 0;	if (argc == 3 && !(ft_strncmp(argv[2], "--save", 7)))			all.save = 1;	all.win.mlx = mlx_init();	check_display_resolution(&all);	all.win.mlx_win = mlx_new_window(all.win.mlx, textures.width, textures.height, "Cub3d!");	init_texture(&all);    init_img(&all);    all.si_co = v_set(cos(46*(M_PI/180)/all.textures.width), sin(46*(M_PI/180)/all.textures.width));	draw_screen(&all);    mlx_hook(all.win.mlx_win, 2, 1L<<0, key_hook, &all);	mlx_hook(all.win.mlx_win, X, 1L << 0, exit, 0);	mlx_loop_hook(all.win.mlx, draw_screen, &all);	mlx_loop(all.win.mlx);	return 0;}